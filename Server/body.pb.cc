// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: body.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "stdafx.h"
#include "body.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace databody {

namespace {

const ::google::protobuf::Descriptor* gameuser_data_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  gameuser_data_reflection_ = NULL;
const ::google::protobuf::Descriptor* gameuser_info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  gameuser_info_reflection_ = NULL;
const ::google::protobuf::Descriptor* staticobject_info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  staticobject_info_reflection_ = NULL;
const ::google::protobuf::Descriptor* login_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  login_reflection_ = NULL;
const ::google::protobuf::Descriptor* join_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  join_reflection_ = NULL;
const ::google::protobuf::Descriptor* exit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  exit_reflection_ = NULL;
const ::google::protobuf::Descriptor* move_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  move_reflection_ = NULL;
const ::google::protobuf::Descriptor* jump_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  jump_reflection_ = NULL;
const ::google::protobuf::Descriptor* skill1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  skill1_reflection_ = NULL;
const ::google::protobuf::Descriptor* commandresult_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  commandresult_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* shapetype_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* commandtype_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* messagetype_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* movedirectiontype_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_body_2eproto() {
  protobuf_AddDesc_body_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "body.proto");
  GOOGLE_CHECK(file != NULL);
  gameuser_data_descriptor_ = file->message_type(0);
  static const int gameuser_data_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, gameobject_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, posx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, posy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, cur_hp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, velx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, vely_),
  };
  gameuser_data_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      gameuser_data_descriptor_,
      gameuser_data::default_instance_,
      gameuser_data_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_data, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(gameuser_data));
  gameuser_info_descriptor_ = file->message_type(1);
  static const int gameuser_info_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_info, gameobject_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_info, max_hp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_info, mass_),
  };
  gameuser_info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      gameuser_info_descriptor_,
      gameuser_info::default_instance_,
      gameuser_info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gameuser_info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(gameuser_info));
  staticobject_info_descriptor_ = file->message_type(2);
  static const int staticobject_info_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, gameobject_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, posx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, posy_),
  };
  staticobject_info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      staticobject_info_descriptor_,
      staticobject_info::default_instance_,
      staticobject_info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(staticobject_info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(staticobject_info));
  login_descriptor_ = file->message_type(3);
  static const int login_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(login, loginstep_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(login, deviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(login, uuid_),
  };
  login_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      login_descriptor_,
      login::default_instance_,
      login_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(login, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(login, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(login));
  join_descriptor_ = file->message_type(4);
  static const int join_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(join, deviceid_),
  };
  join_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      join_descriptor_,
      join::default_instance_,
      join_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(join, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(join, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(join));
  exit_descriptor_ = file->message_type(5);
  static const int exit_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exit, deviceid_),
  };
  exit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      exit_descriptor_,
      exit::default_instance_,
      exit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(exit));
  move_descriptor_ = file->message_type(6);
  static const int move_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, direction_),
  };
  move_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      move_descriptor_,
      move::default_instance_,
      move_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(move));
  jump_descriptor_ = file->message_type(7);
  static const int jump_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(jump, flag_),
  };
  jump_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      jump_descriptor_,
      jump::default_instance_,
      jump_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(jump, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(jump, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(jump));
  skill1_descriptor_ = file->message_type(8);
  static const int skill1_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(skill1, flag_),
  };
  skill1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      skill1_descriptor_,
      skill1::default_instance_,
      skill1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(skill1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(skill1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(skill1));
  commandresult_descriptor_ = file->message_type(9);
  static const int commandresult_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(commandresult, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(commandresult, result_),
  };
  commandresult_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      commandresult_descriptor_,
      commandresult::default_instance_,
      commandresult_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(commandresult, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(commandresult, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(commandresult));
  shapetype_descriptor_ = file->enum_type(0);
  commandtype_descriptor_ = file->enum_type(1);
  messagetype_descriptor_ = file->enum_type(2);
  movedirectiontype_descriptor_ = file->enum_type(3);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_body_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    gameuser_data_descriptor_, &gameuser_data::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    gameuser_info_descriptor_, &gameuser_info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    staticobject_info_descriptor_, &staticobject_info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    login_descriptor_, &login::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    join_descriptor_, &join::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    exit_descriptor_, &exit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    move_descriptor_, &move::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    jump_descriptor_, &jump::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    skill1_descriptor_, &skill1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    commandresult_descriptor_, &commandresult::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_body_2eproto() {
  delete gameuser_data::default_instance_;
  delete gameuser_data_reflection_;
  delete gameuser_info::default_instance_;
  delete gameuser_info_reflection_;
  delete staticobject_info::default_instance_;
  delete staticobject_info_reflection_;
  delete login::default_instance_;
  delete login_reflection_;
  delete join::default_instance_;
  delete join_reflection_;
  delete exit::default_instance_;
  delete exit_reflection_;
  delete move::default_instance_;
  delete move_reflection_;
  delete jump::default_instance_;
  delete jump_reflection_;
  delete skill1::default_instance_;
  delete skill1_reflection_;
  delete commandresult::default_instance_;
  delete commandresult_reflection_;
}

void protobuf_AddDesc_body_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nbody.proto\022\010databody\"\217\001\n\rgameuser_data"
    "\022\030\n\020gameobject_index\030\001 \002(\005\022\r\n\005angle\030\002 \002("
    "\002\022\014\n\004posx\030\003 \002(\002\022\014\n\004posy\030\004 \002(\002\022\016\n\006cur_hp\030"
    "\005 \002(\002\022\r\n\005state\030\006 \002(\005\022\014\n\004velx\030\007 \002(\002\022\014\n\004ve"
    "ly\030\010 \002(\002\"G\n\rgameuser_info\022\030\n\020gameobject_"
    "index\030\001 \002(\005\022\016\n\006max_hp\030\002 \002(\002\022\014\n\004mass\030\003 \002("
    "\002\"n\n\021staticobject_info\022\030\n\020gameobject_ind"
    "ex\030\001 \002(\005\022\t\n\001x\030\002 \003(\002\022\t\n\001y\030\003 \003(\002\022\r\n\005angle\030"
    "\004 \002(\002\022\014\n\004posx\030\005 \002(\002\022\014\n\004posy\030\006 \002(\002\":\n\005log"
    "in\022\021\n\tloginstep\030\001 \002(\005\022\020\n\010deviceid\030\002 \001(\t\022"
    "\014\n\004uuid\030\003 \001(\t\"\030\n\004join\022\020\n\010deviceid\030\001 \002(\t\""
    "\030\n\004exit\022\020\n\010deviceid\030\001 \002(\t\"6\n\004move\022.\n\tdir"
    "ection\030\001 \002(\0162\033.databody.movedirectiontyp"
    "e\"\024\n\004jump\022\014\n\004flag\030\001 \002(\010\"\026\n\006skill1\022\014\n\004fla"
    "g\030\001 \002(\010\"G\n\rcommandresult\022&\n\007command\030\001 \002("
    "\0162\025.databody.commandtype\022\016\n\006result\030\002 \002(\010"
    "*.\n\tshapetype\022\n\n\006ground\020\000\022\007\n\003box\020\001\022\014\n\010ga"
    "meuser\020\002*b\n\013commandtype\022\r\n\tlogintype\020\000\022\014"
    "\n\010jointype\020\001\022\014\n\010exittype\020\002\022\014\n\010movetype\020\003"
    "\022\014\n\010jumptype\020\004\022\014\n\010firetype\020\005*\246\001\n\013message"
    "type\022\022\n\016_gameuser_data\020\000\022\022\n\016_gameuser_in"
    "fo\020\001\022\026\n\022_staticobject_info\020\002\022\n\n\006_login\020\003"
    "\022\t\n\005_join\020\004\022\t\n\005_exit\020\005\022\t\n\005_move\020\006\022\t\n\005_ju"
    "mp\020\007\022\013\n\007_skill1\020\010\022\022\n\016_commandresult\020\t*\?\n"
    "\021movedirectiontype\022\t\n\005_none\020\000\022\t\n\005_left\020\001"
    "\022\n\n\006_right\020\002\022\010\n\004_end\020\003", 1022);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "body.proto", &protobuf_RegisterTypes);
  gameuser_data::default_instance_ = new gameuser_data();
  gameuser_info::default_instance_ = new gameuser_info();
  staticobject_info::default_instance_ = new staticobject_info();
  login::default_instance_ = new login();
  join::default_instance_ = new join();
  exit::default_instance_ = new exit();
  move::default_instance_ = new move();
  jump::default_instance_ = new jump();
  skill1::default_instance_ = new skill1();
  commandresult::default_instance_ = new commandresult();
  gameuser_data::default_instance_->InitAsDefaultInstance();
  gameuser_info::default_instance_->InitAsDefaultInstance();
  staticobject_info::default_instance_->InitAsDefaultInstance();
  login::default_instance_->InitAsDefaultInstance();
  join::default_instance_->InitAsDefaultInstance();
  exit::default_instance_->InitAsDefaultInstance();
  move::default_instance_->InitAsDefaultInstance();
  jump::default_instance_->InitAsDefaultInstance();
  skill1::default_instance_->InitAsDefaultInstance();
  commandresult::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_body_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_body_2eproto {
  StaticDescriptorInitializer_body_2eproto() {
    protobuf_AddDesc_body_2eproto();
  }
} static_descriptor_initializer_body_2eproto_;
const ::google::protobuf::EnumDescriptor* shapetype_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return shapetype_descriptor_;
}
bool shapetype_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* commandtype_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return commandtype_descriptor_;
}
bool commandtype_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* messagetype_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return messagetype_descriptor_;
}
bool messagetype_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* movedirectiontype_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return movedirectiontype_descriptor_;
}
bool movedirectiontype_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int gameuser_data::kGameobjectIndexFieldNumber;
const int gameuser_data::kAngleFieldNumber;
const int gameuser_data::kPosxFieldNumber;
const int gameuser_data::kPosyFieldNumber;
const int gameuser_data::kCurHpFieldNumber;
const int gameuser_data::kStateFieldNumber;
const int gameuser_data::kVelxFieldNumber;
const int gameuser_data::kVelyFieldNumber;
#endif  // !_MSC_VER

gameuser_data::gameuser_data()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void gameuser_data::InitAsDefaultInstance() {
}

gameuser_data::gameuser_data(const gameuser_data& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void gameuser_data::SharedCtor() {
  _cached_size_ = 0;
  gameobject_index_ = 0;
  angle_ = 0;
  posx_ = 0;
  posy_ = 0;
  cur_hp_ = 0;
  state_ = 0;
  velx_ = 0;
  vely_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

gameuser_data::~gameuser_data() {
  SharedDtor();
}

void gameuser_data::SharedDtor() {
  if (this != default_instance_) {
  }
}

void gameuser_data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* gameuser_data::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return gameuser_data_descriptor_;
}

const gameuser_data& gameuser_data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

gameuser_data* gameuser_data::default_instance_ = NULL;

gameuser_data* gameuser_data::New() const {
  return new gameuser_data;
}

void gameuser_data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameobject_index_ = 0;
    angle_ = 0;
    posx_ = 0;
    posy_ = 0;
    cur_hp_ = 0;
    state_ = 0;
    velx_ = 0;
    vely_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool gameuser_data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameobject_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameobject_index_)));
          set_has_gameobject_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_angle;
        break;
      }

      // required float angle = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_posx;
        break;
      }

      // required float posx = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_posx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &posx_)));
          set_has_posx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_posy;
        break;
      }

      // required float posy = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_posy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &posy_)));
          set_has_posy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_cur_hp;
        break;
      }

      // required float cur_hp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_cur_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cur_hp_)));
          set_has_cur_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_state;
        break;
      }

      // required int32 state = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_velx;
        break;
      }

      // required float velx = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_velx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velx_)));
          set_has_velx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_vely;
        break;
      }

      // required float vely = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_vely:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vely_)));
          set_has_vely();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void gameuser_data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameobject_index = 1;
  if (has_gameobject_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameobject_index(), output);
  }

  // required float angle = 2;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->angle(), output);
  }

  // required float posx = 3;
  if (has_posx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->posx(), output);
  }

  // required float posy = 4;
  if (has_posy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->posy(), output);
  }

  // required float cur_hp = 5;
  if (has_cur_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->cur_hp(), output);
  }

  // required int32 state = 6;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->state(), output);
  }

  // required float velx = 7;
  if (has_velx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->velx(), output);
  }

  // required float vely = 8;
  if (has_vely()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->vely(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* gameuser_data::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 gameobject_index = 1;
  if (has_gameobject_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->gameobject_index(), target);
  }

  // required float angle = 2;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->angle(), target);
  }

  // required float posx = 3;
  if (has_posx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->posx(), target);
  }

  // required float posy = 4;
  if (has_posy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->posy(), target);
  }

  // required float cur_hp = 5;
  if (has_cur_hp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->cur_hp(), target);
  }

  // required int32 state = 6;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->state(), target);
  }

  // required float velx = 7;
  if (has_velx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->velx(), target);
  }

  // required float vely = 8;
  if (has_vely()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->vely(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int gameuser_data::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameobject_index = 1;
    if (has_gameobject_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameobject_index());
    }

    // required float angle = 2;
    if (has_angle()) {
      total_size += 1 + 4;
    }

    // required float posx = 3;
    if (has_posx()) {
      total_size += 1 + 4;
    }

    // required float posy = 4;
    if (has_posy()) {
      total_size += 1 + 4;
    }

    // required float cur_hp = 5;
    if (has_cur_hp()) {
      total_size += 1 + 4;
    }

    // required int32 state = 6;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

    // required float velx = 7;
    if (has_velx()) {
      total_size += 1 + 4;
    }

    // required float vely = 8;
    if (has_vely()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void gameuser_data::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const gameuser_data* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const gameuser_data*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void gameuser_data::MergeFrom(const gameuser_data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameobject_index()) {
      set_gameobject_index(from.gameobject_index());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
    if (from.has_posx()) {
      set_posx(from.posx());
    }
    if (from.has_posy()) {
      set_posy(from.posy());
    }
    if (from.has_cur_hp()) {
      set_cur_hp(from.cur_hp());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_velx()) {
      set_velx(from.velx());
    }
    if (from.has_vely()) {
      set_vely(from.vely());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void gameuser_data::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void gameuser_data::CopyFrom(const gameuser_data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool gameuser_data::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void gameuser_data::Swap(gameuser_data* other) {
  if (other != this) {
    std::swap(gameobject_index_, other->gameobject_index_);
    std::swap(angle_, other->angle_);
    std::swap(posx_, other->posx_);
    std::swap(posy_, other->posy_);
    std::swap(cur_hp_, other->cur_hp_);
    std::swap(state_, other->state_);
    std::swap(velx_, other->velx_);
    std::swap(vely_, other->vely_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata gameuser_data::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = gameuser_data_descriptor_;
  metadata.reflection = gameuser_data_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int gameuser_info::kGameobjectIndexFieldNumber;
const int gameuser_info::kMaxHpFieldNumber;
const int gameuser_info::kMassFieldNumber;
#endif  // !_MSC_VER

gameuser_info::gameuser_info()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void gameuser_info::InitAsDefaultInstance() {
}

gameuser_info::gameuser_info(const gameuser_info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void gameuser_info::SharedCtor() {
  _cached_size_ = 0;
  gameobject_index_ = 0;
  max_hp_ = 0;
  mass_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

gameuser_info::~gameuser_info() {
  SharedDtor();
}

void gameuser_info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void gameuser_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* gameuser_info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return gameuser_info_descriptor_;
}

const gameuser_info& gameuser_info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

gameuser_info* gameuser_info::default_instance_ = NULL;

gameuser_info* gameuser_info::New() const {
  return new gameuser_info;
}

void gameuser_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameobject_index_ = 0;
    max_hp_ = 0;
    mass_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool gameuser_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameobject_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameobject_index_)));
          set_has_gameobject_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_max_hp;
        break;
      }

      // required float max_hp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_hp_)));
          set_has_max_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_mass;
        break;
      }

      // required float mass = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_mass:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mass_)));
          set_has_mass();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void gameuser_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameobject_index = 1;
  if (has_gameobject_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameobject_index(), output);
  }

  // required float max_hp = 2;
  if (has_max_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->max_hp(), output);
  }

  // required float mass = 3;
  if (has_mass()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->mass(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* gameuser_info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 gameobject_index = 1;
  if (has_gameobject_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->gameobject_index(), target);
  }

  // required float max_hp = 2;
  if (has_max_hp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->max_hp(), target);
  }

  // required float mass = 3;
  if (has_mass()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->mass(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int gameuser_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameobject_index = 1;
    if (has_gameobject_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameobject_index());
    }

    // required float max_hp = 2;
    if (has_max_hp()) {
      total_size += 1 + 4;
    }

    // required float mass = 3;
    if (has_mass()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void gameuser_info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const gameuser_info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const gameuser_info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void gameuser_info::MergeFrom(const gameuser_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameobject_index()) {
      set_gameobject_index(from.gameobject_index());
    }
    if (from.has_max_hp()) {
      set_max_hp(from.max_hp());
    }
    if (from.has_mass()) {
      set_mass(from.mass());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void gameuser_info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void gameuser_info::CopyFrom(const gameuser_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool gameuser_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void gameuser_info::Swap(gameuser_info* other) {
  if (other != this) {
    std::swap(gameobject_index_, other->gameobject_index_);
    std::swap(max_hp_, other->max_hp_);
    std::swap(mass_, other->mass_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata gameuser_info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = gameuser_info_descriptor_;
  metadata.reflection = gameuser_info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int staticobject_info::kGameobjectIndexFieldNumber;
const int staticobject_info::kXFieldNumber;
const int staticobject_info::kYFieldNumber;
const int staticobject_info::kAngleFieldNumber;
const int staticobject_info::kPosxFieldNumber;
const int staticobject_info::kPosyFieldNumber;
#endif  // !_MSC_VER

staticobject_info::staticobject_info()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void staticobject_info::InitAsDefaultInstance() {
}

staticobject_info::staticobject_info(const staticobject_info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void staticobject_info::SharedCtor() {
  _cached_size_ = 0;
  gameobject_index_ = 0;
  angle_ = 0;
  posx_ = 0;
  posy_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

staticobject_info::~staticobject_info() {
  SharedDtor();
}

void staticobject_info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void staticobject_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* staticobject_info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return staticobject_info_descriptor_;
}

const staticobject_info& staticobject_info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

staticobject_info* staticobject_info::default_instance_ = NULL;

staticobject_info* staticobject_info::New() const {
  return new staticobject_info;
}

void staticobject_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameobject_index_ = 0;
    angle_ = 0;
    posx_ = 0;
    posy_ = 0;
  }
  x_.Clear();
  y_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool staticobject_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameobject_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameobject_index_)));
          set_has_gameobject_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_x;
        break;
      }

      // repeated float x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_x())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_x())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_x;
        if (input->ExpectTag(29)) goto parse_y;
        break;
      }

      // repeated float y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_y())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_y())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_y;
        if (input->ExpectTag(37)) goto parse_angle;
        break;
      }

      // required float angle = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_posx;
        break;
      }

      // required float posx = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_posx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &posx_)));
          set_has_posx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_posy;
        break;
      }

      // required float posy = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_posy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &posy_)));
          set_has_posy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void staticobject_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameobject_index = 1;
  if (has_gameobject_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameobject_index(), output);
  }

  // repeated float x = 2;
  for (int i = 0; i < this->x_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->x(i), output);
  }

  // repeated float y = 3;
  for (int i = 0; i < this->y_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->y(i), output);
  }

  // required float angle = 4;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->angle(), output);
  }

  // required float posx = 5;
  if (has_posx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->posx(), output);
  }

  // required float posy = 6;
  if (has_posy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->posy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* staticobject_info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 gameobject_index = 1;
  if (has_gameobject_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->gameobject_index(), target);
  }

  // repeated float x = 2;
  for (int i = 0; i < this->x_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->x(i), target);
  }

  // repeated float y = 3;
  for (int i = 0; i < this->y_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(3, this->y(i), target);
  }

  // required float angle = 4;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->angle(), target);
  }

  // required float posx = 5;
  if (has_posx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->posx(), target);
  }

  // required float posy = 6;
  if (has_posy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->posy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int staticobject_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameobject_index = 1;
    if (has_gameobject_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameobject_index());
    }

    // required float angle = 4;
    if (has_angle()) {
      total_size += 1 + 4;
    }

    // required float posx = 5;
    if (has_posx()) {
      total_size += 1 + 4;
    }

    // required float posy = 6;
    if (has_posy()) {
      total_size += 1 + 4;
    }

  }
  // repeated float x = 2;
  {
    int data_size = 0;
    data_size = 4 * this->x_size();
    total_size += 1 * this->x_size() + data_size;
  }

  // repeated float y = 3;
  {
    int data_size = 0;
    data_size = 4 * this->y_size();
    total_size += 1 * this->y_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void staticobject_info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const staticobject_info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const staticobject_info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void staticobject_info::MergeFrom(const staticobject_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  x_.MergeFrom(from.x_);
  y_.MergeFrom(from.y_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameobject_index()) {
      set_gameobject_index(from.gameobject_index());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
    if (from.has_posx()) {
      set_posx(from.posx());
    }
    if (from.has_posy()) {
      set_posy(from.posy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void staticobject_info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void staticobject_info::CopyFrom(const staticobject_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool staticobject_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000039) != 0x00000039) return false;

  return true;
}

void staticobject_info::Swap(staticobject_info* other) {
  if (other != this) {
    std::swap(gameobject_index_, other->gameobject_index_);
    x_.Swap(&other->x_);
    y_.Swap(&other->y_);
    std::swap(angle_, other->angle_);
    std::swap(posx_, other->posx_);
    std::swap(posy_, other->posy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata staticobject_info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = staticobject_info_descriptor_;
  metadata.reflection = staticobject_info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int login::kLoginstepFieldNumber;
const int login::kDeviceidFieldNumber;
const int login::kUuidFieldNumber;
#endif  // !_MSC_VER

login::login()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void login::InitAsDefaultInstance() {
}

login::login(const login& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void login::SharedCtor() {
  _cached_size_ = 0;
  loginstep_ = 0;
  deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

login::~login() {
  SharedDtor();
}

void login::SharedDtor() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
  }
}

void login::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* login::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return login_descriptor_;
}

const login& login::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

login* login::default_instance_ = NULL;

login* login::New() const {
  return new login;
}

void login::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    loginstep_ = 0;
    if (has_deviceid()) {
      if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
        deviceid_->clear();
      }
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool login::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 loginstep = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &loginstep_)));
          set_has_loginstep();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_deviceid;
        break;
      }

      // optional string deviceid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_deviceid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->deviceid().data(), this->deviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_uuid;
        break;
      }

      // optional string uuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void login::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 loginstep = 1;
  if (has_loginstep()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->loginstep(), output);
  }

  // optional string deviceid = 2;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deviceid().data(), this->deviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->deviceid(), output);
  }

  // optional string uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* login::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 loginstep = 1;
  if (has_loginstep()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->loginstep(), target);
  }

  // optional string deviceid = 2;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deviceid().data(), this->deviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->deviceid(), target);
  }

  // optional string uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int login::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 loginstep = 1;
    if (has_loginstep()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->loginstep());
    }

    // optional string deviceid = 2;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deviceid());
    }

    // optional string uuid = 3;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void login::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const login* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const login*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void login::MergeFrom(const login& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loginstep()) {
      set_loginstep(from.loginstep());
    }
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void login::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void login::CopyFrom(const login& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool login::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void login::Swap(login* other) {
  if (other != this) {
    std::swap(loginstep_, other->loginstep_);
    std::swap(deviceid_, other->deviceid_);
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata login::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = login_descriptor_;
  metadata.reflection = login_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int join::kDeviceidFieldNumber;
#endif  // !_MSC_VER

join::join()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void join::InitAsDefaultInstance() {
}

join::join(const join& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void join::SharedCtor() {
  _cached_size_ = 0;
  deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

join::~join() {
  SharedDtor();
}

void join::SharedDtor() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (this != default_instance_) {
  }
}

void join::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* join::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return join_descriptor_;
}

const join& join::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

join* join::default_instance_ = NULL;

join* join::New() const {
  return new join;
}

void join::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_deviceid()) {
      if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
        deviceid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool join::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string deviceid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->deviceid().data(), this->deviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void join::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string deviceid = 1;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deviceid().data(), this->deviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->deviceid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* join::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string deviceid = 1;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deviceid().data(), this->deviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->deviceid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int join::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string deviceid = 1;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deviceid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void join::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const join* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const join*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void join::MergeFrom(const join& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void join::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void join::CopyFrom(const join& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool join::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void join::Swap(join* other) {
  if (other != this) {
    std::swap(deviceid_, other->deviceid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata join::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = join_descriptor_;
  metadata.reflection = join_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int exit::kDeviceidFieldNumber;
#endif  // !_MSC_VER

exit::exit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void exit::InitAsDefaultInstance() {
}

exit::exit(const exit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void exit::SharedCtor() {
  _cached_size_ = 0;
  deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

exit::~exit() {
  SharedDtor();
}

void exit::SharedDtor() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (this != default_instance_) {
  }
}

void exit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* exit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return exit_descriptor_;
}

const exit& exit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

exit* exit::default_instance_ = NULL;

exit* exit::New() const {
  return new exit;
}

void exit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_deviceid()) {
      if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
        deviceid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool exit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string deviceid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->deviceid().data(), this->deviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void exit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string deviceid = 1;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deviceid().data(), this->deviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->deviceid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* exit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string deviceid = 1;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deviceid().data(), this->deviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->deviceid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int exit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string deviceid = 1;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deviceid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void exit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const exit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const exit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void exit::MergeFrom(const exit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void exit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void exit::CopyFrom(const exit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool exit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void exit::Swap(exit* other) {
  if (other != this) {
    std::swap(deviceid_, other->deviceid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata exit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = exit_descriptor_;
  metadata.reflection = exit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int move::kDirectionFieldNumber;
#endif  // !_MSC_VER

move::move()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void move::InitAsDefaultInstance() {
}

move::move(const move& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void move::SharedCtor() {
  _cached_size_ = 0;
  direction_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

move::~move() {
  SharedDtor();
}

void move::SharedDtor() {
  if (this != default_instance_) {
  }
}

void move::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* move::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return move_descriptor_;
}

const move& move::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

move* move::default_instance_ = NULL;

move* move::New() const {
  return new move;
}

void move::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    direction_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool move::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .databody.movedirectiontype direction = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::databody::movedirectiontype_IsValid(value)) {
            set_direction(static_cast< ::databody::movedirectiontype >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void move::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .databody.movedirectiontype direction = 1;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->direction(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* move::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .databody.movedirectiontype direction = 1;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->direction(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int move::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .databody.movedirectiontype direction = 1;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void move::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const move* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const move*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void move::MergeFrom(const move& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void move::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void move::CopyFrom(const move& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool move::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void move::Swap(move* other) {
  if (other != this) {
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata move::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = move_descriptor_;
  metadata.reflection = move_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int jump::kFlagFieldNumber;
#endif  // !_MSC_VER

jump::jump()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void jump::InitAsDefaultInstance() {
}

jump::jump(const jump& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void jump::SharedCtor() {
  _cached_size_ = 0;
  flag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

jump::~jump() {
  SharedDtor();
}

void jump::SharedDtor() {
  if (this != default_instance_) {
  }
}

void jump::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* jump::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return jump_descriptor_;
}

const jump& jump::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

jump* jump::default_instance_ = NULL;

jump* jump::New() const {
  return new jump;
}

void jump::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flag_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool jump::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool flag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void jump::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool flag = 1;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->flag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* jump::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool flag = 1;
  if (has_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->flag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int jump::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool flag = 1;
    if (has_flag()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void jump::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const jump* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const jump*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void jump::MergeFrom(const jump& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flag()) {
      set_flag(from.flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void jump::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void jump::CopyFrom(const jump& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool jump::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void jump::Swap(jump* other) {
  if (other != this) {
    std::swap(flag_, other->flag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata jump::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = jump_descriptor_;
  metadata.reflection = jump_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int skill1::kFlagFieldNumber;
#endif  // !_MSC_VER

skill1::skill1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void skill1::InitAsDefaultInstance() {
}

skill1::skill1(const skill1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void skill1::SharedCtor() {
  _cached_size_ = 0;
  flag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

skill1::~skill1() {
  SharedDtor();
}

void skill1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void skill1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* skill1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return skill1_descriptor_;
}

const skill1& skill1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

skill1* skill1::default_instance_ = NULL;

skill1* skill1::New() const {
  return new skill1;
}

void skill1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flag_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool skill1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool flag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void skill1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool flag = 1;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->flag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* skill1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool flag = 1;
  if (has_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->flag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int skill1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool flag = 1;
    if (has_flag()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void skill1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const skill1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const skill1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void skill1::MergeFrom(const skill1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flag()) {
      set_flag(from.flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void skill1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void skill1::CopyFrom(const skill1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool skill1::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void skill1::Swap(skill1* other) {
  if (other != this) {
    std::swap(flag_, other->flag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata skill1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = skill1_descriptor_;
  metadata.reflection = skill1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int commandresult::kCommandFieldNumber;
const int commandresult::kResultFieldNumber;
#endif  // !_MSC_VER

commandresult::commandresult()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void commandresult::InitAsDefaultInstance() {
}

commandresult::commandresult(const commandresult& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void commandresult::SharedCtor() {
  _cached_size_ = 0;
  command_ = 0;
  result_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

commandresult::~commandresult() {
  SharedDtor();
}

void commandresult::SharedDtor() {
  if (this != default_instance_) {
  }
}

void commandresult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* commandresult::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return commandresult_descriptor_;
}

const commandresult& commandresult::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_body_2eproto();
  return *default_instance_;
}

commandresult* commandresult::default_instance_ = NULL;

commandresult* commandresult::New() const {
  return new commandresult;
}

void commandresult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    command_ = 0;
    result_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool commandresult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .databody.commandtype command = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::databody::commandtype_IsValid(value)) {
            set_command(static_cast< ::databody::commandtype >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // required bool result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void commandresult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .databody.commandtype command = 1;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->command(), output);
  }

  // required bool result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->result(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* commandresult::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .databody.commandtype command = 1;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->command(), target);
  }

  // required bool result = 2;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->result(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int commandresult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .databody.commandtype command = 1;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->command());
    }

    // required bool result = 2;
    if (has_result()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void commandresult::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const commandresult* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const commandresult*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void commandresult::MergeFrom(const commandresult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_command()) {
      set_command(from.command());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void commandresult::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void commandresult::CopyFrom(const commandresult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool commandresult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void commandresult::Swap(commandresult* other) {
  if (other != this) {
    std::swap(command_, other->command_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata commandresult::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = commandresult_descriptor_;
  metadata.reflection = commandresult_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace databody

// @@protoc_insertion_point(global_scope)
