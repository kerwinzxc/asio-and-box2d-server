// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: body.proto

#ifndef PROTOBUF_body_2eproto__INCLUDED
#define PROTOBUF_body_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace databody {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_body_2eproto();
void protobuf_AssignDesc_body_2eproto();
void protobuf_ShutdownFile_body_2eproto();

class gameuser_data;
class gameuser_info;
class staticobject_info;
class dumbmob_info;
class dumbmob_data;
class leave_object;
class login;
class join;
class exit;
class move;
class jump;
class skill1;
class commandresult;

enum shapetype {
  ground = 0,
  box = 1,
  gameuser = 2
};
bool shapetype_IsValid(int value);
const shapetype shapetype_MIN = ground;
const shapetype shapetype_MAX = gameuser;
const int shapetype_ARRAYSIZE = shapetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* shapetype_descriptor();
inline const ::std::string& shapetype_Name(shapetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    shapetype_descriptor(), value);
}
inline bool shapetype_Parse(
    const ::std::string& name, shapetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<shapetype>(
    shapetype_descriptor(), name, value);
}
enum commandtype {
  logintype = 0,
  jointype = 1,
  exittype = 2,
  movetype = 3,
  jumptype = 4,
  firetype = 5
};
bool commandtype_IsValid(int value);
const commandtype commandtype_MIN = logintype;
const commandtype commandtype_MAX = firetype;
const int commandtype_ARRAYSIZE = commandtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* commandtype_descriptor();
inline const ::std::string& commandtype_Name(commandtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    commandtype_descriptor(), value);
}
inline bool commandtype_Parse(
    const ::std::string& name, commandtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<commandtype>(
    commandtype_descriptor(), name, value);
}
enum movedirectiontype {
  _none = 0,
  _left = 1,
  _right = 2,
  _end = 3
};
bool movedirectiontype_IsValid(int value);
const movedirectiontype movedirectiontype_MIN = _none;
const movedirectiontype movedirectiontype_MAX = _end;
const int movedirectiontype_ARRAYSIZE = movedirectiontype_MAX + 1;

const ::google::protobuf::EnumDescriptor* movedirectiontype_descriptor();
inline const ::std::string& movedirectiontype_Name(movedirectiontype value) {
  return ::google::protobuf::internal::NameOfEnum(
    movedirectiontype_descriptor(), value);
}
inline bool movedirectiontype_Parse(
    const ::std::string& name, movedirectiontype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<movedirectiontype>(
    movedirectiontype_descriptor(), name, value);
}
// ===================================================================

class gameuser_data : public ::google::protobuf::Message {
 public:
  gameuser_data();
  virtual ~gameuser_data();

  gameuser_data(const gameuser_data& from);

  inline gameuser_data& operator=(const gameuser_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gameuser_data& default_instance();

  void Swap(gameuser_data* other);

  // implements Message ----------------------------------------------

  gameuser_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gameuser_data& from);
  void MergeFrom(const gameuser_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameobject_index = 1;
  inline bool has_gameobject_index() const;
  inline void clear_gameobject_index();
  static const int kGameobjectIndexFieldNumber = 1;
  inline ::google::protobuf::int32 gameobject_index() const;
  inline void set_gameobject_index(::google::protobuf::int32 value);

  // required float angle = 2;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline float angle() const;
  inline void set_angle(float value);

  // required float posx = 3;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosxFieldNumber = 3;
  inline float posx() const;
  inline void set_posx(float value);

  // required float posy = 4;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosyFieldNumber = 4;
  inline float posy() const;
  inline void set_posy(float value);

  // required float cur_hp = 5;
  inline bool has_cur_hp() const;
  inline void clear_cur_hp();
  static const int kCurHpFieldNumber = 5;
  inline float cur_hp() const;
  inline void set_cur_hp(float value);

  // required int32 state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // required float velx = 7;
  inline bool has_velx() const;
  inline void clear_velx();
  static const int kVelxFieldNumber = 7;
  inline float velx() const;
  inline void set_velx(float value);

  // required float vely = 8;
  inline bool has_vely() const;
  inline void clear_vely();
  static const int kVelyFieldNumber = 8;
  inline float vely() const;
  inline void set_vely(float value);

  // required float swordangle = 9;
  inline bool has_swordangle() const;
  inline void clear_swordangle();
  static const int kSwordangleFieldNumber = 9;
  inline float swordangle() const;
  inline void set_swordangle(float value);

  // @@protoc_insertion_point(class_scope:databody.gameuser_data)
 private:
  inline void set_has_gameobject_index();
  inline void clear_has_gameobject_index();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_cur_hp();
  inline void clear_has_cur_hp();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_velx();
  inline void clear_has_velx();
  inline void set_has_vely();
  inline void clear_has_vely();
  inline void set_has_swordangle();
  inline void clear_has_swordangle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameobject_index_;
  float angle_;
  float posx_;
  float posy_;
  float cur_hp_;
  ::google::protobuf::int32 state_;
  float velx_;
  float vely_;
  float swordangle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static gameuser_data* default_instance_;
};
// -------------------------------------------------------------------

class gameuser_info : public ::google::protobuf::Message {
 public:
  gameuser_info();
  virtual ~gameuser_info();

  gameuser_info(const gameuser_info& from);

  inline gameuser_info& operator=(const gameuser_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gameuser_info& default_instance();

  void Swap(gameuser_info* other);

  // implements Message ----------------------------------------------

  gameuser_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gameuser_info& from);
  void MergeFrom(const gameuser_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameobject_index = 1;
  inline bool has_gameobject_index() const;
  inline void clear_gameobject_index();
  static const int kGameobjectIndexFieldNumber = 1;
  inline ::google::protobuf::int32 gameobject_index() const;
  inline void set_gameobject_index(::google::protobuf::int32 value);

  // required float max_hp = 2;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 2;
  inline float max_hp() const;
  inline void set_max_hp(float value);

  // required float mass = 3;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 3;
  inline float mass() const;
  inline void set_mass(float value);

  // @@protoc_insertion_point(class_scope:databody.gameuser_info)
 private:
  inline void set_has_gameobject_index();
  inline void clear_has_gameobject_index();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();
  inline void set_has_mass();
  inline void clear_has_mass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameobject_index_;
  float max_hp_;
  float mass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static gameuser_info* default_instance_;
};
// -------------------------------------------------------------------

class staticobject_info : public ::google::protobuf::Message {
 public:
  staticobject_info();
  virtual ~staticobject_info();

  staticobject_info(const staticobject_info& from);

  inline staticobject_info& operator=(const staticobject_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const staticobject_info& default_instance();

  void Swap(staticobject_info* other);

  // implements Message ----------------------------------------------

  staticobject_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const staticobject_info& from);
  void MergeFrom(const staticobject_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameobject_index = 1;
  inline bool has_gameobject_index() const;
  inline void clear_gameobject_index();
  static const int kGameobjectIndexFieldNumber = 1;
  inline ::google::protobuf::int32 gameobject_index() const;
  inline void set_gameobject_index(::google::protobuf::int32 value);

  // repeated float x = 2;
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x(int index) const;
  inline void set_x(int index, float value);
  inline void add_x(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      x() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // repeated float y = 3;
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y(int index) const;
  inline void set_y(int index, float value);
  inline void add_y(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      y() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_y();

  // required float angle = 4;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 4;
  inline float angle() const;
  inline void set_angle(float value);

  // required float posx = 5;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosxFieldNumber = 5;
  inline float posx() const;
  inline void set_posx(float value);

  // required float posy = 6;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosyFieldNumber = 6;
  inline float posy() const;
  inline void set_posy(float value);

  // @@protoc_insertion_point(class_scope:databody.staticobject_info)
 private:
  inline void set_has_gameobject_index();
  inline void clear_has_gameobject_index();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > x_;
  ::google::protobuf::int32 gameobject_index_;
  float angle_;
  ::google::protobuf::RepeatedField< float > y_;
  float posx_;
  float posy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static staticobject_info* default_instance_;
};
// -------------------------------------------------------------------

class dumbmob_info : public ::google::protobuf::Message {
 public:
  dumbmob_info();
  virtual ~dumbmob_info();

  dumbmob_info(const dumbmob_info& from);

  inline dumbmob_info& operator=(const dumbmob_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dumbmob_info& default_instance();

  void Swap(dumbmob_info* other);

  // implements Message ----------------------------------------------

  dumbmob_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dumbmob_info& from);
  void MergeFrom(const dumbmob_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameobject_index = 1;
  inline bool has_gameobject_index() const;
  inline void clear_gameobject_index();
  static const int kGameobjectIndexFieldNumber = 1;
  inline ::google::protobuf::int32 gameobject_index() const;
  inline void set_gameobject_index(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required float mass = 3;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 3;
  inline float mass() const;
  inline void set_mass(float value);

  // required float max_hp = 4;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 4;
  inline float max_hp() const;
  inline void set_max_hp(float value);

  // @@protoc_insertion_point(class_scope:databody.dumbmob_info)
 private:
  inline void set_has_gameobject_index();
  inline void clear_has_gameobject_index();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameobject_index_;
  ::google::protobuf::int32 type_;
  float mass_;
  float max_hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static dumbmob_info* default_instance_;
};
// -------------------------------------------------------------------

class dumbmob_data : public ::google::protobuf::Message {
 public:
  dumbmob_data();
  virtual ~dumbmob_data();

  dumbmob_data(const dumbmob_data& from);

  inline dumbmob_data& operator=(const dumbmob_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dumbmob_data& default_instance();

  void Swap(dumbmob_data* other);

  // implements Message ----------------------------------------------

  dumbmob_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dumbmob_data& from);
  void MergeFrom(const dumbmob_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameobject_index = 1;
  inline bool has_gameobject_index() const;
  inline void clear_gameobject_index();
  static const int kGameobjectIndexFieldNumber = 1;
  inline ::google::protobuf::int32 gameobject_index() const;
  inline void set_gameobject_index(::google::protobuf::int32 value);

  // required float angle = 2;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline float angle() const;
  inline void set_angle(float value);

  // required float posx = 3;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosxFieldNumber = 3;
  inline float posx() const;
  inline void set_posx(float value);

  // required float posy = 4;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosyFieldNumber = 4;
  inline float posy() const;
  inline void set_posy(float value);

  // required float cur_hp = 5;
  inline bool has_cur_hp() const;
  inline void clear_cur_hp();
  static const int kCurHpFieldNumber = 5;
  inline float cur_hp() const;
  inline void set_cur_hp(float value);

  // required float velx = 6;
  inline bool has_velx() const;
  inline void clear_velx();
  static const int kVelxFieldNumber = 6;
  inline float velx() const;
  inline void set_velx(float value);

  // required float vely = 7;
  inline bool has_vely() const;
  inline void clear_vely();
  static const int kVelyFieldNumber = 7;
  inline float vely() const;
  inline void set_vely(float value);

  // @@protoc_insertion_point(class_scope:databody.dumbmob_data)
 private:
  inline void set_has_gameobject_index();
  inline void clear_has_gameobject_index();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_cur_hp();
  inline void clear_has_cur_hp();
  inline void set_has_velx();
  inline void clear_has_velx();
  inline void set_has_vely();
  inline void clear_has_vely();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameobject_index_;
  float angle_;
  float posx_;
  float posy_;
  float cur_hp_;
  float velx_;
  float vely_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static dumbmob_data* default_instance_;
};
// -------------------------------------------------------------------

class leave_object : public ::google::protobuf::Message {
 public:
  leave_object();
  virtual ~leave_object();

  leave_object(const leave_object& from);

  inline leave_object& operator=(const leave_object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const leave_object& default_instance();

  void Swap(leave_object* other);

  // implements Message ----------------------------------------------

  leave_object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const leave_object& from);
  void MergeFrom(const leave_object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameobject_index = 1;
  inline bool has_gameobject_index() const;
  inline void clear_gameobject_index();
  static const int kGameobjectIndexFieldNumber = 1;
  inline ::google::protobuf::int32 gameobject_index() const;
  inline void set_gameobject_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:databody.leave_object)
 private:
  inline void set_has_gameobject_index();
  inline void clear_has_gameobject_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameobject_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static leave_object* default_instance_;
};
// -------------------------------------------------------------------

class login : public ::google::protobuf::Message {
 public:
  login();
  virtual ~login();

  login(const login& from);

  inline login& operator=(const login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login& default_instance();

  void Swap(login* other);

  // implements Message ----------------------------------------------

  login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login& from);
  void MergeFrom(const login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 loginstep = 1;
  inline bool has_loginstep() const;
  inline void clear_loginstep();
  static const int kLoginstepFieldNumber = 1;
  inline ::google::protobuf::int32 loginstep() const;
  inline void set_loginstep(::google::protobuf::int32 value);

  // optional string deviceid = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 2;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:databody.login)
 private:
  inline void set_has_loginstep();
  inline void clear_has_loginstep();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deviceid_;
  ::std::string* uuid_;
  ::google::protobuf::int32 loginstep_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static login* default_instance_;
};
// -------------------------------------------------------------------

class join : public ::google::protobuf::Message {
 public:
  join();
  virtual ~join();

  join(const join& from);

  inline join& operator=(const join& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const join& default_instance();

  void Swap(join* other);

  // implements Message ----------------------------------------------

  join* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const join& from);
  void MergeFrom(const join& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string deviceid = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:databody.join)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deviceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static join* default_instance_;
};
// -------------------------------------------------------------------

class exit : public ::google::protobuf::Message {
 public:
  exit();
  virtual ~exit();

  exit(const exit& from);

  inline exit& operator=(const exit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exit& default_instance();

  void Swap(exit* other);

  // implements Message ----------------------------------------------

  exit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exit& from);
  void MergeFrom(const exit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string deviceid = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:databody.exit)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deviceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static exit* default_instance_;
};
// -------------------------------------------------------------------

class move : public ::google::protobuf::Message {
 public:
  move();
  virtual ~move();

  move(const move& from);

  inline move& operator=(const move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const move& default_instance();

  void Swap(move* other);

  // implements Message ----------------------------------------------

  move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const move& from);
  void MergeFrom(const move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .databody.movedirectiontype direction = 1;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 1;
  inline ::databody::movedirectiontype direction() const;
  inline void set_direction(::databody::movedirectiontype value);

  // @@protoc_insertion_point(class_scope:databody.move)
 private:
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static move* default_instance_;
};
// -------------------------------------------------------------------

class jump : public ::google::protobuf::Message {
 public:
  jump();
  virtual ~jump();

  jump(const jump& from);

  inline jump& operator=(const jump& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const jump& default_instance();

  void Swap(jump* other);

  // implements Message ----------------------------------------------

  jump* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const jump& from);
  void MergeFrom(const jump& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline bool flag() const;
  inline void set_flag(bool value);

  // @@protoc_insertion_point(class_scope:databody.jump)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static jump* default_instance_;
};
// -------------------------------------------------------------------

class skill1 : public ::google::protobuf::Message {
 public:
  skill1();
  virtual ~skill1();

  skill1(const skill1& from);

  inline skill1& operator=(const skill1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skill1& default_instance();

  void Swap(skill1* other);

  // implements Message ----------------------------------------------

  skill1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skill1& from);
  void MergeFrom(const skill1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline bool flag() const;
  inline void set_flag(bool value);

  // @@protoc_insertion_point(class_scope:databody.skill1)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static skill1* default_instance_;
};
// -------------------------------------------------------------------

class commandresult : public ::google::protobuf::Message {
 public:
  commandresult();
  virtual ~commandresult();

  commandresult(const commandresult& from);

  inline commandresult& operator=(const commandresult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const commandresult& default_instance();

  void Swap(commandresult* other);

  // implements Message ----------------------------------------------

  commandresult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const commandresult& from);
  void MergeFrom(const commandresult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .databody.commandtype command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::databody::commandtype command() const;
  inline void set_command(::databody::commandtype value);

  // required bool result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline bool result() const;
  inline void set_result(bool value);

  // @@protoc_insertion_point(class_scope:databody.commandresult)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int command_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_body_2eproto();
  friend void protobuf_AssignDesc_body_2eproto();
  friend void protobuf_ShutdownFile_body_2eproto();

  void InitAsDefaultInstance();
  static commandresult* default_instance_;
};
// ===================================================================


// ===================================================================

// gameuser_data

// required int32 gameobject_index = 1;
inline bool gameuser_data::has_gameobject_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gameuser_data::set_has_gameobject_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gameuser_data::clear_has_gameobject_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gameuser_data::clear_gameobject_index() {
  gameobject_index_ = 0;
  clear_has_gameobject_index();
}
inline ::google::protobuf::int32 gameuser_data::gameobject_index() const {
  return gameobject_index_;
}
inline void gameuser_data::set_gameobject_index(::google::protobuf::int32 value) {
  set_has_gameobject_index();
  gameobject_index_ = value;
}

// required float angle = 2;
inline bool gameuser_data::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gameuser_data::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gameuser_data::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gameuser_data::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float gameuser_data::angle() const {
  return angle_;
}
inline void gameuser_data::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// required float posx = 3;
inline bool gameuser_data::has_posx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gameuser_data::set_has_posx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gameuser_data::clear_has_posx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gameuser_data::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float gameuser_data::posx() const {
  return posx_;
}
inline void gameuser_data::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// required float posy = 4;
inline bool gameuser_data::has_posy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gameuser_data::set_has_posy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gameuser_data::clear_has_posy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gameuser_data::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float gameuser_data::posy() const {
  return posy_;
}
inline void gameuser_data::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// required float cur_hp = 5;
inline bool gameuser_data::has_cur_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gameuser_data::set_has_cur_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gameuser_data::clear_has_cur_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gameuser_data::clear_cur_hp() {
  cur_hp_ = 0;
  clear_has_cur_hp();
}
inline float gameuser_data::cur_hp() const {
  return cur_hp_;
}
inline void gameuser_data::set_cur_hp(float value) {
  set_has_cur_hp();
  cur_hp_ = value;
}

// required int32 state = 6;
inline bool gameuser_data::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gameuser_data::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gameuser_data::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gameuser_data::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 gameuser_data::state() const {
  return state_;
}
inline void gameuser_data::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// required float velx = 7;
inline bool gameuser_data::has_velx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gameuser_data::set_has_velx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gameuser_data::clear_has_velx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gameuser_data::clear_velx() {
  velx_ = 0;
  clear_has_velx();
}
inline float gameuser_data::velx() const {
  return velx_;
}
inline void gameuser_data::set_velx(float value) {
  set_has_velx();
  velx_ = value;
}

// required float vely = 8;
inline bool gameuser_data::has_vely() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void gameuser_data::set_has_vely() {
  _has_bits_[0] |= 0x00000080u;
}
inline void gameuser_data::clear_has_vely() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void gameuser_data::clear_vely() {
  vely_ = 0;
  clear_has_vely();
}
inline float gameuser_data::vely() const {
  return vely_;
}
inline void gameuser_data::set_vely(float value) {
  set_has_vely();
  vely_ = value;
}

// required float swordangle = 9;
inline bool gameuser_data::has_swordangle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void gameuser_data::set_has_swordangle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void gameuser_data::clear_has_swordangle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void gameuser_data::clear_swordangle() {
  swordangle_ = 0;
  clear_has_swordangle();
}
inline float gameuser_data::swordangle() const {
  return swordangle_;
}
inline void gameuser_data::set_swordangle(float value) {
  set_has_swordangle();
  swordangle_ = value;
}

// -------------------------------------------------------------------

// gameuser_info

// required int32 gameobject_index = 1;
inline bool gameuser_info::has_gameobject_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gameuser_info::set_has_gameobject_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gameuser_info::clear_has_gameobject_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gameuser_info::clear_gameobject_index() {
  gameobject_index_ = 0;
  clear_has_gameobject_index();
}
inline ::google::protobuf::int32 gameuser_info::gameobject_index() const {
  return gameobject_index_;
}
inline void gameuser_info::set_gameobject_index(::google::protobuf::int32 value) {
  set_has_gameobject_index();
  gameobject_index_ = value;
}

// required float max_hp = 2;
inline bool gameuser_info::has_max_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gameuser_info::set_has_max_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gameuser_info::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gameuser_info::clear_max_hp() {
  max_hp_ = 0;
  clear_has_max_hp();
}
inline float gameuser_info::max_hp() const {
  return max_hp_;
}
inline void gameuser_info::set_max_hp(float value) {
  set_has_max_hp();
  max_hp_ = value;
}

// required float mass = 3;
inline bool gameuser_info::has_mass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gameuser_info::set_has_mass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gameuser_info::clear_has_mass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gameuser_info::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float gameuser_info::mass() const {
  return mass_;
}
inline void gameuser_info::set_mass(float value) {
  set_has_mass();
  mass_ = value;
}

// -------------------------------------------------------------------

// staticobject_info

// required int32 gameobject_index = 1;
inline bool staticobject_info::has_gameobject_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void staticobject_info::set_has_gameobject_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void staticobject_info::clear_has_gameobject_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void staticobject_info::clear_gameobject_index() {
  gameobject_index_ = 0;
  clear_has_gameobject_index();
}
inline ::google::protobuf::int32 staticobject_info::gameobject_index() const {
  return gameobject_index_;
}
inline void staticobject_info::set_gameobject_index(::google::protobuf::int32 value) {
  set_has_gameobject_index();
  gameobject_index_ = value;
}

// repeated float x = 2;
inline int staticobject_info::x_size() const {
  return x_.size();
}
inline void staticobject_info::clear_x() {
  x_.Clear();
}
inline float staticobject_info::x(int index) const {
  return x_.Get(index);
}
inline void staticobject_info::set_x(int index, float value) {
  x_.Set(index, value);
}
inline void staticobject_info::add_x(float value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
staticobject_info::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
staticobject_info::mutable_x() {
  return &x_;
}

// repeated float y = 3;
inline int staticobject_info::y_size() const {
  return y_.size();
}
inline void staticobject_info::clear_y() {
  y_.Clear();
}
inline float staticobject_info::y(int index) const {
  return y_.Get(index);
}
inline void staticobject_info::set_y(int index, float value) {
  y_.Set(index, value);
}
inline void staticobject_info::add_y(float value) {
  y_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
staticobject_info::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedField< float >*
staticobject_info::mutable_y() {
  return &y_;
}

// required float angle = 4;
inline bool staticobject_info::has_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void staticobject_info::set_has_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void staticobject_info::clear_has_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void staticobject_info::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float staticobject_info::angle() const {
  return angle_;
}
inline void staticobject_info::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// required float posx = 5;
inline bool staticobject_info::has_posx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void staticobject_info::set_has_posx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void staticobject_info::clear_has_posx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void staticobject_info::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float staticobject_info::posx() const {
  return posx_;
}
inline void staticobject_info::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// required float posy = 6;
inline bool staticobject_info::has_posy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void staticobject_info::set_has_posy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void staticobject_info::clear_has_posy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void staticobject_info::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float staticobject_info::posy() const {
  return posy_;
}
inline void staticobject_info::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// -------------------------------------------------------------------

// dumbmob_info

// required int32 gameobject_index = 1;
inline bool dumbmob_info::has_gameobject_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dumbmob_info::set_has_gameobject_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dumbmob_info::clear_has_gameobject_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dumbmob_info::clear_gameobject_index() {
  gameobject_index_ = 0;
  clear_has_gameobject_index();
}
inline ::google::protobuf::int32 dumbmob_info::gameobject_index() const {
  return gameobject_index_;
}
inline void dumbmob_info::set_gameobject_index(::google::protobuf::int32 value) {
  set_has_gameobject_index();
  gameobject_index_ = value;
}

// required int32 type = 2;
inline bool dumbmob_info::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dumbmob_info::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dumbmob_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dumbmob_info::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 dumbmob_info::type() const {
  return type_;
}
inline void dumbmob_info::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required float mass = 3;
inline bool dumbmob_info::has_mass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dumbmob_info::set_has_mass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dumbmob_info::clear_has_mass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dumbmob_info::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float dumbmob_info::mass() const {
  return mass_;
}
inline void dumbmob_info::set_mass(float value) {
  set_has_mass();
  mass_ = value;
}

// required float max_hp = 4;
inline bool dumbmob_info::has_max_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dumbmob_info::set_has_max_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dumbmob_info::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dumbmob_info::clear_max_hp() {
  max_hp_ = 0;
  clear_has_max_hp();
}
inline float dumbmob_info::max_hp() const {
  return max_hp_;
}
inline void dumbmob_info::set_max_hp(float value) {
  set_has_max_hp();
  max_hp_ = value;
}

// -------------------------------------------------------------------

// dumbmob_data

// required int32 gameobject_index = 1;
inline bool dumbmob_data::has_gameobject_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dumbmob_data::set_has_gameobject_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dumbmob_data::clear_has_gameobject_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dumbmob_data::clear_gameobject_index() {
  gameobject_index_ = 0;
  clear_has_gameobject_index();
}
inline ::google::protobuf::int32 dumbmob_data::gameobject_index() const {
  return gameobject_index_;
}
inline void dumbmob_data::set_gameobject_index(::google::protobuf::int32 value) {
  set_has_gameobject_index();
  gameobject_index_ = value;
}

// required float angle = 2;
inline bool dumbmob_data::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dumbmob_data::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dumbmob_data::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dumbmob_data::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float dumbmob_data::angle() const {
  return angle_;
}
inline void dumbmob_data::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// required float posx = 3;
inline bool dumbmob_data::has_posx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dumbmob_data::set_has_posx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dumbmob_data::clear_has_posx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dumbmob_data::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float dumbmob_data::posx() const {
  return posx_;
}
inline void dumbmob_data::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// required float posy = 4;
inline bool dumbmob_data::has_posy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dumbmob_data::set_has_posy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dumbmob_data::clear_has_posy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dumbmob_data::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float dumbmob_data::posy() const {
  return posy_;
}
inline void dumbmob_data::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// required float cur_hp = 5;
inline bool dumbmob_data::has_cur_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dumbmob_data::set_has_cur_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dumbmob_data::clear_has_cur_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dumbmob_data::clear_cur_hp() {
  cur_hp_ = 0;
  clear_has_cur_hp();
}
inline float dumbmob_data::cur_hp() const {
  return cur_hp_;
}
inline void dumbmob_data::set_cur_hp(float value) {
  set_has_cur_hp();
  cur_hp_ = value;
}

// required float velx = 6;
inline bool dumbmob_data::has_velx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dumbmob_data::set_has_velx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dumbmob_data::clear_has_velx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dumbmob_data::clear_velx() {
  velx_ = 0;
  clear_has_velx();
}
inline float dumbmob_data::velx() const {
  return velx_;
}
inline void dumbmob_data::set_velx(float value) {
  set_has_velx();
  velx_ = value;
}

// required float vely = 7;
inline bool dumbmob_data::has_vely() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dumbmob_data::set_has_vely() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dumbmob_data::clear_has_vely() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dumbmob_data::clear_vely() {
  vely_ = 0;
  clear_has_vely();
}
inline float dumbmob_data::vely() const {
  return vely_;
}
inline void dumbmob_data::set_vely(float value) {
  set_has_vely();
  vely_ = value;
}

// -------------------------------------------------------------------

// leave_object

// required int32 gameobject_index = 1;
inline bool leave_object::has_gameobject_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void leave_object::set_has_gameobject_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void leave_object::clear_has_gameobject_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void leave_object::clear_gameobject_index() {
  gameobject_index_ = 0;
  clear_has_gameobject_index();
}
inline ::google::protobuf::int32 leave_object::gameobject_index() const {
  return gameobject_index_;
}
inline void leave_object::set_gameobject_index(::google::protobuf::int32 value) {
  set_has_gameobject_index();
  gameobject_index_ = value;
}

// -------------------------------------------------------------------

// login

// required int32 loginstep = 1;
inline bool login::has_loginstep() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login::set_has_loginstep() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login::clear_has_loginstep() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login::clear_loginstep() {
  loginstep_ = 0;
  clear_has_loginstep();
}
inline ::google::protobuf::int32 login::loginstep() const {
  return loginstep_;
}
inline void login::set_loginstep(::google::protobuf::int32 value) {
  set_has_loginstep();
  loginstep_ = value;
}

// optional string deviceid = 2;
inline bool login::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& login::deviceid() const {
  return *deviceid_;
}
inline void login::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void login::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void login::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* login::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uuid = 3;
inline bool login::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& login::uuid() const {
  return *uuid_;
}
inline void login::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void login::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void login::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* login::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// join

// required string deviceid = 1;
inline bool join::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void join::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void join::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void join::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& join::deviceid() const {
  return *deviceid_;
}
inline void join::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void join::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void join::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* join::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* join::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void join::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// exit

// required string deviceid = 1;
inline bool exit::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exit::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exit::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exit::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& exit::deviceid() const {
  return *deviceid_;
}
inline void exit::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void exit::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void exit::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exit::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* exit::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exit::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// move

// required .databody.movedirectiontype direction = 1;
inline bool move::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void move::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void move::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void move::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::databody::movedirectiontype move::direction() const {
  return static_cast< ::databody::movedirectiontype >(direction_);
}
inline void move::set_direction(::databody::movedirectiontype value) {
  assert(::databody::movedirectiontype_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// -------------------------------------------------------------------

// jump

// required bool flag = 1;
inline bool jump::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jump::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jump::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jump::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool jump::flag() const {
  return flag_;
}
inline void jump::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// skill1

// required bool flag = 1;
inline bool skill1::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skill1::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skill1::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skill1::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool skill1::flag() const {
  return flag_;
}
inline void skill1::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// commandresult

// required .databody.commandtype command = 1;
inline bool commandresult::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void commandresult::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void commandresult::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void commandresult::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::databody::commandtype commandresult::command() const {
  return static_cast< ::databody::commandtype >(command_);
}
inline void commandresult::set_command(::databody::commandtype value) {
  assert(::databody::commandtype_IsValid(value));
  set_has_command();
  command_ = value;
}

// required bool result = 2;
inline bool commandresult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void commandresult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void commandresult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void commandresult::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool commandresult::result() const {
  return result_;
}
inline void commandresult::set_result(bool value) {
  set_has_result();
  result_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace databody

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::databody::shapetype>() {
  return ::databody::shapetype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::databody::commandtype>() {
  return ::databody::commandtype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::databody::movedirectiontype>() {
  return ::databody::movedirectiontype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_body_2eproto__INCLUDED
